# 

## TAG : 정렬 , Arrays.sort , collections.sort , 람다식 조건


### 숫자를 정렬하면 작은->큰 순으로 정렬이 가능하고, 문자열을 정렬하면 사전순으로 정렬이 가능하다.

### 문자열로 정렬을 해야 [3, 30, 34, 5, 9] 를 정렬할때에 "9534303"이 나오는게 아니라 "9534330"이 나온다.

- 
  ### 나의 풀이 

1. 문자의 자리수를 맞추기 위해 모든 숫자를 문자열로 바꾸고 3번(0~1000까지의 숫자가 나올수 있으므로...) 덧붙인다.
2. Comparator.reverseOrder를 통해 역순으로 사전정렬한다.
3. 3번 덧붙인걸 빼기 위해 길이의 /3을 한다.
4. 모든 배열이 0일때에는 000 이 나오면안되고 0만 나와야함으로 중간에 if문 처리 추가.


- 
  ### 타인의 풀이


```
정렬할때에 Arrays.sort 할때에 compare 조건을 넣을수 있다.
조건은 아래 람다식의 내용과 같다. 
다만 Arrays.sort 와 collections.sort 의 차이만 있을뿐 내용은 같다. 
String.join("", stringNumbers);를 통해 배열을 합칠수 있다.
```

```
람다식 내용
list에서 순서대로 2개의 요소를 추출합니다. 이를 각각 a와 b로 정의하고 String 자료형으로 만들어 as와 bs를 만듭니다.
그리고 return문에 보면 as + bs와 bs + as를 수행합니다. 여기서 주목해야하는 부분은 자리를 교체했다는 점입니다(= bs + as 케이스). 만약 as = 10, bs = 20인 경우, 연산의 결과는 1020과 2010으로 나옵니다.
이 결과 값을 가지고 Integer.compare()를 수행합니다. Integer 라이브러리의 compare 함수를 살펴보면 x==y 인 경우 0을 반환, x < y인 경우 음수, x > y인 경우 양수를 반환합니다. 1020과 2010을 비교하면 x < y인 경우로, 음수를 반환합니다.
이제 Integer.compare()로부터 나온 연산 결과를 Collections.sort() 내부의 comparator에서 사용하게 됩니다. comparator의 경우 음수는 오름차순, 양수는 내림차순으로 요소의 자리를 바꿔줍니다.
그러나 위의 코드에서는 sb + ab는 인위적으로 자리 바꿈을 수행하였습니다. 
그러므로 (ab + sb) < (sb + ab)인 경우 자리바꿈을 수행해야하는 상황인겁니다. 
문제의 조건에 부합하려면 20이 10보다 앞에 위치해야합니다. 
하지만 Integer.compare()함수에서 음수를 반환하고 이를 전달받은 Collections.sort()는 음수를 오름차순으로 정렬하므로 문제의 조건에 부합하지 않습니다. 
즉, Integer.compare()는 (ab + sb) < (sb + ab)인 경우에 음수를 반환하지만 sb가 ab보다 앞에 위치하도록 만들기 위해서 Integer.compare() 앞에 마이너스(-) 부호를 붙여 양수를 반환하게 하여 Collections.sort()가 내림차순으로 정렬하도록 하는 것입니다.
```




